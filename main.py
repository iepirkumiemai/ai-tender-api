# ===============================================
# main.py — AI Tender Engine v10.0 (JSON + PDF)
# ===============================================

import os
import zipfile
import tempfile
from typing import List

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.responses import FileResponse, JSONResponse

import mammoth
from pdfminer.high_level import extract_text
from openai import OpenAI

from fpdf import FPDF

# -----------------------------------------------
# OpenAI klienta inicializācija
# -----------------------------------------------
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

app = FastAPI(
    title="AI Iepirkumi – Tender Engine",
    version="10.0",
    description="AI-based tender evaluation: JSON + Professional PDF output"
)

# ======================================================
# Teksta attīrīšana
# ======================================================

def clean(text: str) -> str:
    return text.replace("\x00", "").strip()

# ======================================================
# Failu ekstrakcijas metodes
# ======================================================

def extract_pdf(path: str) -> str:
    try:
        return clean(extract_text(path))
    except:
        return ""

def extract_docx(path: str) -> str:
    try:
        with open(path, "rb") as f:
            return clean(mammoth.extract_raw_text(f).value)
    except:
        return ""

def extract_edoc(path: str) -> str:
    text = ""
    try:
        with zipfile.ZipFile(path, "r") as z:
            for name in z.namelist():
                if name.endswith(".xml") or name.endswith(".txt"):
                    text += clean(z.read(name).decode(errors="ignore"))
    except:
        pass
    return text

def extract_zip(path: str) -> str:
    combined = ""
    try:
        with zipfile.ZipFile(path, "r") as z:
            for name in z.namelist():
                if name.endswith("/"):
                    continue

                with tempfile.NamedTemporaryFile(delete=False) as tmp:
                    tmp.write(z.read(name))
                    tmp_path = tmp.name

                lname = name.lower()

                if lname.endswith(".pdf"):
                    combined += extract_pdf(tmp_path)
                elif lname.endswith(".docx"):
                    combined += extract_docx(tmp_path)
                elif lname.endswith(".edoc"):
                    combined += extract_edoc(tmp_path)
                elif lname.endswith(".zip"):
                    combined += extract_zip(tmp_path)

                os.unlink(tmp_path)

    except:
        pass

    return combined

# ======================================================
# AI – prasību analīze
# ======================================================

def ai_parse_requirements(text: str) -> str:

    prompt = f"""
Extract and logically structure these REQUIREMENT DOCUMENTS.
Return STRICT JSON:

{{
  "requirements": [...],
  "summary": "...",
  "key_points": [...],
  "risks": [...]
}}

--- DOCUMENT TEXT ---
{text}
"""

    r = client.responses.create(
        model="gpt-4.1",
        input=prompt
    )

    return r.output_text

# ======================================================
# AI – kandidāta salīdzinājums
# ======================================================

def ai_compare_candidate(requirements_json: str, candidate_text: str) -> str:

    prompt = f"""
Compare REQUIREMENTS with CANDIDATE DOCUMENT.

Return STRICT JSON:

{{
  "match_score": 0-100,
  "status": "GREEN | YELLOW | RED",
  "matched_requirements": [...],
  "missing_requirements": [...],
  "risks": [...],
  "summary": "..."
}}

Rules:
- GREEN = score >= 90
- YELLOW = 60–89
- RED = <60

--- REQUIREMENTS ---
{requirements_json}

--- CANDIDATE ---
{candidate_text}
"""

    r = client.responses.create(
        model="gpt-4.1",
        input=prompt
    )

    return r.output_text


# ======================================================
#  PDF GENERATORS
# ======================================================

class PDFReport(FPDF):
    def header(self):
        self.set_font("DejaVu", "B", 18)
        self.set_text_color(0, 51, 102)
        self.cell(0, 12, "Vērtējums", ln=True, align="C")
        self.ln(4)
        self.set_draw_color(0, 51, 102)
        self.set_line_width(1)
        self.line(10, 28, 200, 28)
        self.ln(6)

    def footer(self):
        self.set_y(-15)
        self.set_font("DejaVu", "", 9)
        self.set_text_color(120, 120, 120)
        self.cell(0, 10, "Generated by AI Tender Engine v10.0", align="C")


def generate_pdf(requirements_json, candidate_results):

    pdf = PDFReport()
    pdf.add_page()

    pdf.add_font("DejaVu", "", "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", uni=True)
    pdf.add_font("DejaVu", "B", "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", uni=True)
    pdf.set_font("DejaVu", "", 12)

    # -----------------------------------------
    # Requirements Summary
    # -----------------------------------------
    pdf.set_font("DejaVu", "B", 14)
    pdf.set_text_color(0, 51, 102)
    pdf.cell(0, 10, "Prasību kopsavilkums", ln=True)

    pdf.set_font("DejaVu", "", 11)
    pdf.set_text_color(0, 0, 0)
    pdf.multi_cell(0, 7, requirements_json)

    pdf.ln(4)

    # -----------------------------------------
    # Candidate Results
    # -----------------------------------------
    pdf.set_font("DejaVu", "B", 14)
    pdf.set_text_color(0, 51, 102)
    pdf.cell(0, 10, "Kandidātu vērtējums", ln=True)

    for cand in candidate_results:

        pdf.set_font("DejaVu", "B", 12)
        pdf.ln(3)
        pdf.cell(0, 8, f"Kandidāts: {cand['candidate']}", ln=True)

        eval = cand["evaluation"]

        # status color + icon
        if "GREEN" in eval:
            icon = "✓"
            pdf.set_text_color(15, 169, 88)
        elif "YELLOW" in eval:
            icon = "⚠"
            pdf.set_text_color(255, 180, 0)
        else:
            icon = "✖"
            pdf.set_text_color(224, 41, 41)

        pdf.set_font("DejaVu", "B", 12)
        pdf.cell(0, 8, f"Status: {icon} {eval}", ln=True)

        pdf.set_font("DejaVu", "", 11)
        pdf.set_text_color(0, 0, 0)
        pdf.multi_cell(0, 6, eval)
        pdf.ln(4)

    # Save PDF
    out_path = "/tmp/report.pdf"
    pdf.output(out_path)
    return out_path


# ======================================================
#   Endpoint: JSON /compare_files
# ======================================================

@app.post("/compare_files")
async def compare_files(
    requirements: List[UploadFile] = File(...),
    candidates: List[UploadFile] = File(...)
):

    # Extract REQUIREMENTS
    text_req = ""
    for f in requirements:
        temp = tempfile.NamedTemporaryFile(delete=False)
        temp.write(await f.read())
        temp_path = temp.name
        temp.close()

        name = f.filename.lower()
        if name.endswith(".pdf"):
            text_req += extract_pdf(temp_path)
        elif name.endswith(".docx"):
            text_req += extract_docx(temp_path)
        elif name.endswith(".edoc"):
            text_req += extract_edoc(temp_path)
        elif name.endswith(".zip"):
            text_req += extract_zip(temp_path)

        os.unlink(temp_path)

    req_json = ai_parse_requirements(text_req)

    # Extract CANDIDATES
    cand_results = []

    for f in candidates:
        temp = tempfile.NamedTemporaryFile(delete=False)
        temp.write(await f.read())
        temp_path = temp.name
        temp.close()

        name = f.filename.lower()
        if not name.endswith(".zip"):
            raise HTTPException(400, "Candidate must be ZIP")

        text_cand = extract_zip(temp_path)
        os.unlink(temp_path)

        evaluation = ai_compare_candidate(req_json, text_cand)

        cand_results.append({
            "candidate": f.filename,
            "evaluation": evaluation
        })

    return {
        "status": "OK",
        "requirements_parsed": req_json,
        "candidates": cand_results
    }



# ======================================================
#   Endpoint: PDF /compare_files_pdf
# ======================================================

@app.post("/compare_files_pdf")
async def compare_files_pdf(
    requirements: List[UploadFile] = File(...),
    candidates: List[UploadFile] = File(...)
):

    # SAME LOGIC AS /compare_files
    text_req = ""
    for f in requirements:
        temp = tempfile.NamedTemporaryFile(delete=False)
        temp.write(await f.read())
        temp_path = temp.name
        temp.close()

        name = f.filename.lower()
        if name.endswith(".pdf"):
            text_req += extract_pdf(temp_path)
        elif name.endswith(".docx"):
            text_req += extract_docx(temp_path)
        elif name.endswith(".edoc"):
            text_req += extract_edoc(temp_path)
        elif name.endswith(".zip"):
            text_req += extract_zip(temp_path)

        os.unlink(temp_path)

    req_json = ai_parse_requirements(text_req)

    cand_results = []

    for f in candidates:
        temp = tempfile.NamedTemporaryFile(delete=False)
        temp.write(await f.read())
        temp_path = temp.name
        temp.close()

        if not f.filename.lower().endswith(".zip"):
            raise HTTPException(400, "Candidate must be ZIP")

        text_cand = extract_zip(temp_path)
        os.unlink(temp_path)

        evaluation = ai_compare_candidate(req_json, text_cand)

        cand_results.append({
            "candidate": f.filename,
            "evaluation": evaluation
        })

    # Generate PDF
    pdf_path = generate_pdf(req_json, cand_results)

    return FileResponse(
        pdf_path,
        media_type="application/pdf",
        filename="tender_report.pdf"
    )
